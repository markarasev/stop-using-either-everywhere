<!doctype html>
<html>

	<head>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>

	<body>

		<div class="reveal">
			<div class="slides">

				<!-- Titre -->
				<section>
					<h1>Stop using <mark>Either</mark> everywhere!</h1>
					<aside class="notes">
						Type dont je trouve l'usage abusif dans beaucoup de bases de code. Je 
						vais tenter d'expliquer pourquoi je pense comme ça, et quelles 
						alternatives j'ai pu trouver.
						Sujet à débat, je vais donner beaucoup d'avis personnels. Si vous n'êtes
						pas d'accord, c'est normal. Cela dit, tout se dont je vais parler ici 
						est inspiré de faits réels, issus de mon expérience de développeur.
					</aside>
				</section>

				<!-- 1. Exemples d'utilisation-->
				<section>
					<section>
						<h2>Quelques exemples d'utilisation</h2>
						À vous de me donner l'intention de l'auteur.
						<aside class="notes">
							chaque mauvaise réponse = une présentation au SLUG
							(ya pas de mauvaises réponses)
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[FileValidationError, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">FileValidationError est une erreur métier</li>
							<li class="fragment">DataFile est l'entrée validée</li>
						</ul>
						<aside class="notes">
							convention : erreurs à gauche (merci pour les gauchers), résultats 
							corrects à droite
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[SourceFile, BinaryFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">catégorisation</li>
							<li class="fragment">BinaryFile est une entrée métier à traiter</li>
							<li class="fragment">SourceFile aussi</li>
						</ul>
						<aside class="notes">
							DAFUK le biais à droite ?
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">
								UnexpectedFile est une erreur métier (plus ambigu qu'
								UnexpectedFileError ou FileValidationError)
							</li>
							<li class="fragment">DataFile est l'entrée validée</li>
						</ul>
						<aside class="notes">
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">catégorisation ?</li>
							<li class="fragment">DataFile est une entrée métier à traiter</li>
							<li class="fragment">
								UnexpectedFile ressemble à une erreur mais en est-ce une vraiment ?
							</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">catégorisation ?</li>
							<li class="fragment">
								UnexpectedFile ressemble à une erreur mais est à droite
							</li>
							<li class="fragment">
								DataFile ressemble à une entrée métier à traiter mais est à gauche
							</li>
							<li class="fragment">brainfuck</li>
						</ul>
						<aside class="notes">
							Ça, c'est du code que j'ai écrit. Si un jour tu tombes dessus Sylvain, 
							tu seras prévenu.
						</aside>
					</section>
					<!-- refaire les mêmes exemples avec Or plus tard et voir comment 
						l'interprétation évolue (moins de doutes, détetion d'erreurs de 
						programmation ?).-->
				</section>

				<!-- 
					ici ou plus bas : oui mais Marc, pourquoi tu fais pas une sealed family? 
					Ben peut-être que j'ai pas la main sur les définitions des types DataFile, 
					UnexpectedFile, SourceFile et BinayFile et qu'elles se trouvent dans des 
					dépendances externes. Les wrapper dans une sealed family reviendrait à 
					faire exactement la même chose qu'Either. Et même, ça serait 
					potentiellement rébarbatif si je devais faire une sealed family par 
					couple que je souhaite retourner à chaque fonction.
				-->

				<!-- 2. C'est quoi Either ? -->
				<section>
					<h2>Mais au fait, c'est quoi <mark>Either</mark> exactement ?</h2>
					<!-- scaladoc, union disjointe, etc. -->
					<!-- relister les différents exemples sur une slide -->
					<!-- placer ici ou ailleurs que devant les multiples cas d'usages 
						d'Either, s'appuyer uniquement sur une convention est insuffisant, 
						le type est trop général -->
					<!-- déplacer ces notes dans une sous-slide plus bas ou ailleurs -->
					<aside class="notes">
						L'interprétation dépend du contexte, de l'expérience de celui qui 
						lit le code et de son parcours, des coding-rules de l'équipe, etc.
					</aside>
					<!-- autres inconvénients d'Either ici ? (implicit class 
					maison pour scala 2.11, withFilter 2.12?, ) -->
				</section>

				<!-- validation, il existe un paquet de libs (en lister) pour en faire 
					mais on ne parlera que de celles que je connais, introduire scalactic 
					et Or, cats.Validated ? -->
				<!-- reprendre les exemples et proposer des alternatives si nécessaire -->
				<!-- avantages / inconvénients (tuyauterie [mais c'est la garantie de ne 
					pas faire n'importe quoi ?], badMap, map, meaningful type over convention, 
					Every > cats.Nel, accumulation, limitations: see TRM code [??], ...) -->
				
				<!-- partie 2 : composition avec d'autres monades -->
				<!-- problème de l'API asynchrone avec gestion des erreurs (proposer une 
					API exemple) : Future[Either], Future[Or], même combat -->
				<!-- Monad transformer ? Naah. -->
				<!-- liste de solutions (cats.IO, EitherT, ZIO), on ne parlera que de 
					celles que je connais encore une fois -->
				<!-- ZIO, avantages / inconvénients (requiert un zio.Runtime [threadpools], 
					ou force l'utilisateur à faire du ZIO,
					donc à ne pas en abuser quitte à faire de la tuyauterie en core une fois, 
					peut-être que des IO monads plus génériques [comme cats.IO ?] permettent 
					de contourner ce problème, cependant IO ne veut toujours rien dire [sauf 
					si tout le main est dans une IO monad, ce qui est rarement le cas dans 
					nos bases de code qui font du akka-stream, etc où on introduit ZIO]) 
					en résumé = better Future (canal d'erreurs)
				-->
				<!-- revoir l'API avec ZIO, porblème de la compatibilité erreurs / 
					exceptions ? -->
				<!-- Option ? autres ? -->

				<!-- liste d'exemples Either / Or / IO et demander à l'audience ce qu'elle 
					en pense ? -->

				<!-- comme d'hab, there is no silver bullet -->
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>

	</body>

</html>
