<!doctype html>
<html>

	<head>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Stop Using Either Everywhere!</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>

	<body>

		<div class="reveal">
			<div class="slides">



				<!-- Titre -->
				<section>
					<h1>Stop using <mark>Either</mark> everywhere!</h1>
					<aside class="notes">
						Type dont je trouve l'usage abusif dans beaucoup de bases de code. Je 
						vais tenter d'expliquer pourquoi je pense comme √ßa, et quelles 
						alternatives j'ai pu trouver.
						Sujet √† d√©bat, je vais donner beaucoup d'avis personnels. Si vous n'√™tes
						pas d'accord, c'est normal. Cela dit, tout se dont je vais parler ici 
						est inspir√© de faits r√©els, issus de mon exp√©rience de d√©veloppeur.
					</aside>
				</section>



				<!-- 1. Exemples d'utilisation -->
				<section>
					<section>
						<h2>Quelques exemples d'utilisation</h2>
						√Ä vous de me donner l'intention de l'auteur.
						<aside class="notes">
							chaque mauvaise r√©ponse = une pr√©sentation au SLUG
							(ya pas de mauvaises r√©ponses)
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[FileValidationError, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">FileValidationError est une erreur m√©tier</li>
							<li class="fragment">DataFile est l'entr√©e valid√©e</li>
						</ul>
						<aside class="notes">
							convention : erreurs √† gauche (merci pour les gauchers), r√©sultats 
							corrects √† droite
						</aside>
					</section>
					<!-- Pas s√ªr que ce soit franchement n√©cessaire √† ce stade. C'est bien 
					pour l'exhaustivit√© mais risque de perdre de vue l'objectif de montrer 
					l'ambigu√Øt√©. -->
					<!-- <section>
						<pre><code class="scala" data-trim>
							def decodeFile(file: File): Either[FileDecodingError, DecodedFile]
						</code></pre>
						<ul> -->
							<!-- augmenter l'espacement entre les lignes ? -->
							<!-- <li class="fragment">traitement</li>
							<li class="fragment">FileDecodingError est une erreur de traitement</li>
							<li class="fragment">DecodedFile est le r√©sultat du traitement</li>
						</ul>
						<aside class="notes">
						</aside>
					</section> -->
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[SourceFile, BinaryFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">cat√©gorisation</li>
							<li class="fragment">BinaryFile est une entr√©e m√©tier √† traiter</li>
							<li class="fragment">SourceFile aussi</li>
						</ul>
						<aside class="notes">
							DAFUK le biais √† droite ?
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">DataFile est l'entr√©e valid√©e</li>
							<li class="fragment">
								UnexpectedFile est une erreur m√©tier (plus ambigu qu'
								UnexpectedFileError ou FileValidationError)
							</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">DataFile est une entr√©e m√©tier √† traiter</li>
							<li class="fragment">
								UnexpectedFile ressemble √† une erreur mais en est-ce une vraiment ?
							</li>
							<li class="fragment">cat√©gorisation ou validation ?</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">cat√©gorisation ?</li>
							<li class="fragment">
								UnexpectedFile ressemble √† une erreur mais est √† droite
							</li>
							<li class="fragment">
								DataFile ressemble √† une entr√©e m√©tier √† traiter mais est √† gauche
							</li>
							<li class="fragment">brainfuck</li>
						</ul>
						<aside class="notes">
							√áa, c'est du code que j'ai √©crit. Si un jour tu tombes dessus Sylvain, 
							tu seras pr√©venu.
						</aside>
					</section>
				</section>



				<!-- 2. C'est quoi Either ? -->
				<section>
					<section>
						<!-- trouver un meilleur truc pour mettre en valeur le code dans les 
							titres -->
						<h2>Mais au fait, c'est quoi <mark>Either</mark> exactement ?</h2>
					</section>
					<!-- This is cool but I don't want to rely on internet connection. -->
					<!-- <section data-background-iframe="https://www.scala-lang.org/api/current/scala/util/Either.html"> -->
					<!-- </section> -->
					<section>
						<img data-src="assets/either_scaladoc.png">
					</section>
					<section>
						<h3>Qu'est-ce qu'une r√©union disjointe ? üá´üá∑üêî</h3>
						<ul>
							<li class="fragment">coproduit</li>
							<li class="fragment">sum type</li>
							<li class="fragment">(encore plein d'autres noms)</li>
							<!-- Utiliser autre chose qu'Either/Left/Right ici ? 
								Fruit/Apple/Banana ? Autre chose de plus binaire ? -->
							<li class="fragment"><pre><code class="scala" data-trim>
								sealed trait Either
								case object Left extends Either
								case object Right extends Either
							</code></pre></li>
						</ul>
						<aside class="notes">
							Pourquoi ya autant de noms pour d√©signer la m√™me chose ? Je ne sais 
							pas, demandez aux scientifiques.
						</aside>
					</section>
					<section>
						S√©mantiquement...
						<pre class="fragment"><code class="scala" data-trim>
							sealed trait File
							case object BinaryFile extends File
							case object SourceFile extends File
							val file: File = ???
						</code></pre>
						<div class="fragment">
							<h3><==></h3>
							<pre><code class="scala" data-trim>
								case object BinaryFile
								case object SourceFile
								val file: Either[BinaryFile, SourceFile] = ???
							</code></pre>
						</div>
					</section>
					<!-- Ici ou entre les parties 1 et 2 ? L'avantage d'ici c'est les sealed 
					families ont d√©j√† √©t√© √©voqu√©es. -->
					<section>
						<h3>Pourquoi utiliser Either[BinaryFile, SourceFile] ?</h3>
						<ul>
							<li class="fragment">pas forc√©ment le besoin (ni le temps) de tout mod√©liser tout le temps</li>
							<li class="fragment"><pre><code class="scala" data-trim>
								import fancy.jar.BinaryFile
								import other.fancy.jar.SourceFile
	
								val file: Either[BinaryFile, SourceFile] = ???
							</code></pre></li>
						</ul>
						<aside class="notes">
							Oui mais Marc, pourquoi tu fais pas une sealed family 
							(et on garderait Either pour la gestion d'erreurs) ? 

							 - Pour le retour d'une seule fonction, c'est peut-√™tre overkill.

							 - Peut-√™tre que j'ai pas la main sur les d√©finitions des types 
							SourceFile et BinaryFile et qu'elles se trouvent dans des 
							d√©pendances externes. Les wrapper dans une sealed family reviendrait √† 
							faire exactement la m√™me chose qu'Either. Et m√™me, √ßa serait 
							potentiellement tr√®s r√©barbatif si je devais faire une sealed family 
							par couple que je souhaite retourner √† chaque fonction.
						</aside>
					</section>
				</section>



				<!-- 3. Pourquoi Either c'est pas toujours bien ? -->
				<section>
					<section>
						<h2>Pourquoi utiliser <mark>Either</mark> n'est pas toujours id√©al ?</h2>
          </section>
          
          <!-- 3.1. Ambigu√Øt√© -->
					<section>
						<!-- Trouver mieux comme titre ? -->
						<h3>Le code est la montagne √† gravir</h3>
						<p>L'interpr√©tation du code d√©pend :</p>
						<ul>
							<li class="fragment">du contexte du projet</li>
							<li class="fragment">de l'exp√©rience personnelle du lecteur</li>
							<li class="fragment">des coding-rules de l'√©quipe (conventions)</li>
							<li class="fragment">etc.</li>
						</ul>
						<p class="fragment">Beaucoup de variables.</p>
					</section>
					<section>
						<h3>Les types sont des amis</h3>
						<p>L'interpr√©tation d'un type d√©pend (id√©alement) :</p>
						<ul>
							<li class="fragment">de sa d√©finition uniquement</li>
						</ul>
						<!-- TODO espacer -->
						<p class="fragment">Or la combinaison de la d√©finition d'Either et 
							son usage conventionnel cr√©ent de l'ambigu√Øt√©.</p>
						<!-- ins√©rer GIF ? peut-√™tre 
							https://giphy.com/gifs/filmeditor-christmas-movies-vanessa-ferlito-3o6wrFfkrw1xEk35VS ? -->
						<aside class="notes">
							Les types sont aussi l√† pour nous aider dans cette t√¢che (en principe).
						</aside>
					</section>
					<section>
						<h3>Either est trop g√©n√©ral</h3>
						<!-- def decodeFile(file: File): Either[FileDecodingError, DecodedFile] -->
						<pre><code class="scala" data-trim>
							// validation : Left = erreur
							def validateFile(file: File): Either[FileValidationError, DataFile]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[SourceFile, BinaryFile]

							// validation ?
							def validateFile(file: File): Either[UnexpectedFile, DataFile]

							// cat√©gorisation ?
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]

							// ??
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<aside class="notes">
							<!-- devant les multiples cas d'usages d'Either -->
							Si on reprend nos exemples de d√©part, aucun n'est vraiment un m√©susage 
							du type Either. Donc mon avis est que s'appuyer uniquement sur une 
							convention est insuffisant, car le type est trop g√©n√©ral.
						</aside>
          </section>
          
          <!-- 3.2. Versions de Scala -->
					<section>
						<h3>Scala 2.11</h3>
						<pre><code class="scala" data-trim>
							object MonadicEither {

							  implicit class EitherMonadicOps[A, B](e: Either[A, B]) {

						      def flatMap[A1 >: A, B1](f: B => Either[A1, B1]): Either[A1, B1] = 
						        e match {
						          case Right(b) => f(b)
						          case _        => e.asInstanceOf[Either[A1, B1]]
						        }
										
						        /* ... */
						</code></pre>
						<pre><code class="scala" data-trim>
							import MonadicEither._

							Right(1).flapMap(Left("Error"))
						</code></pre>
						<aside class="notes">
							Qui utilise encore scala 2.11 ? Nous mais chut.
							On copie-colle du code, mais aimerait faire autre chose de notre 
							temps et √©viter de maintenir ce code, m√™me si il y a peu de risques.
						</aside>
					</section>
					<section>
						<h3>Cross-compile</h3>
						<img data-src="assets/monadic_either.png">
						<pre><code class="scala" data-trim>
							// scala 2.12
							object MonadicEither
						</code></pre>
						<pre><code class="scala" data-trim>
							import MonadicEither._

							Right(1).flapMap(Left("Error"))
						</code></pre>
						<aside class="notes">
							Oblig√©s d'avoir un objet MonadicEither vide en scala 2.12+ pour
							cross-compiler du code en 2.11.
						</aside>
          </section>
          
          <!-- 3.3. Divers -->
					<section>
						<h3>Gardes</h3>
						<pre><code class="scala" data-trim>
							for {
							  i <- Right(1)
							  if i > 0
							} yield i
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// error: value withFilter is not a member of Right[Double,Int]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							for (x: Int <- right1) yield x
							// error: value withFilter is not a member of Right[Double,Int]
						</code></pre>
						<aside class="notes">
							Demander √† l'audience ce qu'il se passe pour le premier exemple.
							
							Les "refutable-patterns" ne fonctionnent pas non plus.
						</aside>
					</section>
					<section>
						<h3>Accumulation d'erreurs</h3>
						<pre><code class="scala" data-trim>
							def retire(worker: Worker): Either[List[CannotRetireError], Pensioner] = {
							  var errors = List.empty // erf
							  if (worker.age < 62) 
							    errors = CannotRetireError.TooYoung +: errors // uuh
							  if (worker.workedQuarters < 172) 
							    errors = CannotRetireError.DidNotWorkedEnough +: errors // ooh
							  if (errors.isEmpty) Right(Pensioner(worker)) else Left(errors)
							}

							val marc = Worker(age = 27, workedQuarters = 15)
							retire(marc) // Left(Seq(TooYoung, DidNotWorkedEnough))
						</code></pre>
						<aside class="notes">
							On est tout nu pour faire de l'accumulation, oblig√© de faire du 
							mutable.
							Ah, et √ßa serait bien d'avoir un type de liste non vide pour les 
							erreurs.
						</aside>
					</section>
					<section>
						<h3>Traverse</h3>
						<pre><code class="scala" data-trim>
							val eithers: List[Either[CannotRetireError, Pensioner]] =
							  Left(TooYoung) :: Right(marc) :: Left(DidNotWorkedEnough) :: Nil

							val todo: Either[List[CannotRetireError], List[Pensioner]] = ???
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
						  val eithers: List[Either[List[CannotRetireError], Pensioner]] = 
						    List(
						      Left(TooYoung :: DidNotWorkedEnough),
						      Right(marc),
						      Left(TooYoung :: Nil)
						    )

						  val todo: Either[List[CannotRetireError], List[Pensioner]] = ???
						</code></pre>
						<p class="fragment">Qui a envie d'√©crire ce code ?</p>
						<aside class="notes">
							(on peut voir que Marc s'en est sorti)
							(si des gens r√©pondent oui dire "√áa me rassure, je ne suis pas le 
							seul √† √™tre masochiste.")
						</aside>
          </section>
          
				</section>



				<!-- 4. Alternatives pour la validation / gestion des erreurs -->
				<section>
					<section data-transition=none>
						<h2>Validation</h2>
						<ul>
							<li>scalactic.Or</li>
							<li>cats.Validated</li>
							<li>...</li>
							<!-- list more -->
						</ul>
						<aside class="notes">
							Il existe un paquet de libs pour faire de la validation, entre autres ...
							On va se concentrer sur celle que je connais, scalactic.
						</aside>
					</section>
					<section data-transition=none>
						<h2>Validation</h2>
						<ul>
							<li><mark>scalactic.Or</mark></li>
							<li>cats.Validated</li>
							<li>...</li>
							<!-- list more -->
						</ul>
					</section>
				</section>



				<!-- 5. Scalactic -->
				<section>

          <!-- 5.1. G√©n√©ralit√©s -->
					<section>
						<h2>Scalactic</h2>
						<ul>
							<li class="fragment">fondation de Scalatest</li>
							<li class="fragment">504 classes</li>
							<li class="fragment">1,5 Mo</li>
							<li class="fragment">d√©veloppement actif</li>
						</ul>
						<aside class="notes">
							- (donc d√©j√† dans ton scope de test si tu utilises Scalatest)
							- petite librairie (cats-core 2.1.0 2072 classes 4,7 Mo) mais plus 
							tellement : a doubl√© de volume entre la 3.0.8 et la 3.1.0 
							(315 -> 504 classes, 706 Ko -> 1,5 Mo)
							- 3.1.0 sortie le 29/11 dernier
						</aside>
          </section>
          
          <!-- 5.2. Or -->
					<section>
						<h3>scalactic.Or</h3>
						<ul>
							<li class="fragment">Either[L, R] devient Or[G, B]</li>
							<li class="fragment">Left devient Good</li>
							<li class="fragment">Right devient Bad</li>
							<li class="fragment">erreurs √† droite</li>
						</ul>
						<aside class="notes">
							ne respecte pas la convention
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							for {
							  x <- Right(1)
							  y <- Left("Error")
							} yield x + y // Left("Error")
						</code></pre>
						<pre><code class="scala" data-trim>
							for {
							  x <- Good(1)
							  y <- Bad("Error")
							} yield x + y // Bad("Error")
						</code></pre>
						<aside class="notes">
							Les types Good et Bad portent une s√©mantique contrairement √† Left et Right.
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							// validation
							def validateFile(file: File): Either[FileValidationError, DataFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// validation
							def validateFile(file: File): Or[DataFile, FileValidationError]
						</code></pre>
					</section>
					<!-- Pas s√ªr que ce soit franchement n√©cessaire √† ce stade. C'est bien 
					pour l'exhaustivit√© mais risque de perdre de vue l'objectif de montrer 
					l'ambigu√Øt√©. -->
					<!-- <section>
						<pre><code class="scala" data-trim>
							def decodeFile(file: File): Either[FileDecodingError, DecodedFile]
						</code></pre>
						<aside class="notes">
						</aside>
					</section> -->
					<section>
						<pre><code class="scala" data-trim>
							// cat√©gorisation
							def classifyFile(file: File): Either[SourceFile, BinaryFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// Bad[SourceFile] ??
							// erreur de programmation manifeste
							def classifyFile(file: File): Or[BinaryFile, SourceFile]
						</code></pre>
						<aside class="notes">
							Ne doit pas changer, ne rentre pas dans le use-case de Or.
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							// UnexpectedFile est une erreur ?
							def validateFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// UnexpectedFile est une erreur car Bad
							def validateFile(file: File): Or[DataFile, UnexpectedFile]
						</code></pre>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							// cat√©gorisation
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// validation
							def classifyFile(file: File): Or[DataFile, UnexpectedFile]
						</code></pre>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							// cat√©gorisation
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// erreur de programmation manifeste
							def classifyFile(file: File): Or[UnexpectedFile, DataFile]
						</code></pre>
						<aside class="notes">
							Mauvais usage du type Or.
						</aside>
					</section>
					<section>
						<h3>Moins d'ambigu√Øt√©</h3>
						<!-- def decodeFile(file: File): Either[FileDecodingError, DecodedFile] -->
						<pre><code class="scala" data-trim>
							// validation : Bad = erreur
							def validateFile(file: File): Or[DataFile, FileValidationError]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[SourceFile, BinaryFile]

							// validation : Bad = erreur
							def validateFile(file: File): Or[DataFile, UnexpectedFile]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<aside class="notes">
							moins de doutes + d√©tetion d'erreurs de programmation
						</aside>
          </section>
					<section>
            pas de diff√©rences entre les versions de Scala
          </section>
					<section>
            <h3>Inconv√©nients de Or 1/2</h3>
              la tuyauterie...
              <pre><code class="scala" data-trim>
                Or.from(Right(1)) // Good(1)
                Or.from(Left("error")) // Bad("error")

                Good(1).toEither // Right(1)
                Bad("error").toEither // Left("error")
              </code></pre>
						<aside class="notes">
              Mais quelque-part, devoir faire de la tuyauterie c'est la garantie 
              de ne pas m√©langer les choux et les carottes, i.e. de ne pas m√©langer 
              des Bad avec des Left qui seraient des valeurs m√©tier.
						</aside>
          </section>
          <section>
            En parlant de tuyauterie :
            <pre><code class="scala" data-trim>
              Or.from(aTry) 
              Or.from(option, orElse)
              
              or.toOption
              or.toSeq
              or.toTry
            </code></pre>
          </section>
          <section>
            <h3>Inconv√©nients de Or 2/2</h3>
            Erreurs √† droite -> principle of least surprise bafou√©
            <!-- TODO spacing -->
            (cats.Validated, ZIO et certainement d'autres respectent la convention)
						<aside class="notes">
              Ne respecte pas la convention (principle of least surprise).
              Pose des probl√®mes aux coll√®gues en cours d'appropriation de la 
              librairie dans une base de code en cours de migration.
						</aside>
          </section>
          
          <!-- 5.3. Accumulation -->
					<section>
						<h3>Notation infixe</h3>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Or[DataFile, FileValidationError]
						</code></pre>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): DataFile Or FileValidationError
						</code></pre>
					</section>
					<section>
						<h3>Every</h3>
						<pre><code class="scala" data-trim>
							One("Too young.") // Every[String]
							
							Many("Too young.", "Did not worked enough.") // Every[String]
						</code></pre>
						<aside class="notes">
							NonEmptyList back√©e par un Vector, va nous servir pour l'accumulation.
						</aside>
					</section>
					<!-- d√©finir DidNotWorkedEnough, Worker et Pensioner ? -->
					<section>
						<pre><code class="scala" data-trim>
							import org.scalactic.Accumulation._
						</code></pre>
					</section>
					<section>
						<h3>Accumulation avec withGood 1/3</h3>
						<pre><code class="scala" data-trim>
							sealed trait ParseError
							case object EmptyName extends ParseError
							case object NegativeAge extends ParseError
							case object InvalidAge extends ParseError
						</code></pre>
						<pre><code class="scala" data-trim>
							case class Person(name: String, age: Int)
						</code></pre>
						<aside class="notes">
							Dans l'exemple qui va suivre on va vouloir valider des inputs textuels 
							pour cr√©er une personne dans notre syst√®me.
						</aside>
					</section>
					<section>
						<h3>Accumulation avec withGood 2/3</h3>
						<pre><code class="scala" data-trim>
							def parseName(input: String): String Or One[EmptyName] = {
							  val trimmed = input.trim
							  if (!trimmed.isEmpty) Good(trimmed) else Bad(One(EmptyName))
							}
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							def parseAge(input: String): Int Or One[ParseError] = try {
							  val age = input.trim.toInt
							  if (age >= 0) Good(age) else Bad(One(NegativeAge))
							} catch { case _: NumberFormatException => Bad(One(InvalidAge)) }
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							def parsePerson(inputName: String, inputAge: String)
							: Person Or Every[ParseError] =
							  withGood(parseName(inputName), parseAge(inputAge)) { 
							    (name, age) => Person(name, age) 
							  }
						</code></pre>
						<aside class="notes">
							Scalactic offre plusieurs moyens de faire de l'accumulation d'erreurs. 

							Notation infixe (j'aime bien pour limiter les []).

							Exemple de la doc.
						</aside>
					</section>
					<section>
						<h3>Accumulation avec withGood 3/3</h3>
						<pre><code class="scala" data-trim>
							parsePerson("Bridget Jones", "29")
							// Result: Good(Person(Bridget Jones,29))
							
							parsePerson("Bridget Jones", "")
							// Result: Bad(One(InvalidAge))
							
							parsePerson("Bridget Jones", "-29")
							// Result: Bad(One(NegativeAge))
							
							parsePerson("", "")
							// Result: Bad(Many(InvalidAge, NegativeAge))
						</code></pre>
						<aside class="notes">
						</aside>
					</section>
					<section>
						<h3>Accumulation avec when 1/2</h3>
						<pre><code class="scala" data-trim>
							sealed trait CannotRetireError
							case object TooYoung extends CannotRetireError
							case object DidNotWorkedEnough extends CannotRetireError
						</code></pre>
						<aside class="notes">
							On revient √† notre exemple avec le syst√®me de retraites dont voici 
							les erreurs.
						</aside>
					</section>
					<section>
						<h3>Accumulation avec when 2/2</h3>
						<pre><code class="scala" data-trim>
							def isOldEnough(worker: Worker): Validation[CannotRetireError] =
							  if (worker.age >= 62) Pass else Fail(TooYoung)
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							def hasWorkedEnough(worker: Worker): Validation[CannotRetireError] =
							  if (worker.workedQuarters >= 172) Pass else Fail(DidNotWorkedEnough)
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							def retire(worker: Worker): Or[Pensioner, Every[CannotRetireError]] = 
							  Good(worker).when(isOldEnough, hasWorkedEnough).map(Pensioner.apply)
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							val marc = Worker(age = 27, workedQuarters = 15)
							retire(marc) // Bad(Many(TooYoung, DidNotWorkedEnough))
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							val somebody = Worker(age = 65, workedQuarters = 181)
							retire(somebody) // Good(Pensioner(...))
						</code></pre>
          </section>
          <section>
            <h3>Limitations 1/2</h3>
            firstGood?
            <pre><code class="scala" data-trim>
              def resolveFile(inputFile: Path): List[Path] Or Every[InputError] = /*...*/
              def resolveGlob(inputGlob: Path): List[Path] Or Every[InputError] = /*...*/

              val pathsOrErrors: List[Path] Or Every[InputError] = 
                firstGood(resolveFilePath(inputPath), resolveGlobPath(inputPath))
            </code></pre>
						<aside class="notes">
              Validation supporte l'op√©rateur && mais pas ||. Ait d√ª impl√©menter 
              une implicit class de Or avec une m√©thode whenOneOf.
						</aside>
          </section>
          <section>
            <h3>Limitations 2/2</h3>
            Validation ||
            <pre><code class="scala" data-trim>
              def hasFrenchHeaders(file: File): Validation[DecodeError] = /*...*/
              def hasEnglishHeaders(file: File): Validation[DecodeError] = /*...*/

              Good(file).when(hasFrenchHeaders && hasEnglishHeaders) // OK
              Good(file).when(hasFrenchHeaders || hasEnglishHeaders) // compile error
            </code></pre>
          </section>
          <section>
						<pre><code class="scala" data-trim>
              val aGoodOne: Int Or String = Good(1)
              aGoodOne.accumulating // Int Or One[String]
						</code></pre>
          </section>
          <section>
						<h3>Traverse</h3>
						<pre><code class="scala" data-trim>
              val ors: List[Pensioner Or CannotRetireError] =
                Bad(TooYoung) :: Good(marc) :: Bad(DidNotWorkedEnough) :: Nil

              val accumulatingOrs: List[Pensioner Or One[CannotRetireError]] = 
                ors.map(_.accumulating)
                
              val pensionersOrErrors: List[Pensioner] Or Every[CannotRetireError] =
                accumulatingOrs.combined // needs import org.scalactic.Accumulation._
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
              val ors: List[Pensioner Or Every[CannotRetireError]] = List(
                Bad(Many(TooYoung, DidNotWorkedEnough)),
                Good(marc),
                Bad(One(TooYoung))
              )

              val pensionersOrErrors: List[Pensioner] Or Every[CannotRetireError] = 
                ors.combined // needs import org.scalactic.Accumulation._
						</code></pre>
						<aside class="notes">
              La subtilit√© c'est qu'il faut √™tre sur des ors accumulatifs.
						</aside>
          </section>

          <!-- 5.4. Divers -->
          <section>
            withFilter est d√©fini via Validation :
            <pre><code class="scala" data-trim>
              def greaterThan0(i: Int): Validation[String] =
                if (i > 0) Pass else Fail(s"$i is less than or equal to 0")
                
              for {
                i <- Good(-1)
                if greaterThan0(i)
              } yield i // Bad("-1 is less than or equal to 0")
            </code></pre>
						<aside class="notes">
              Pas tr√®s pratique, en r√©alit√© pas vraiment impl√©ment√©, d√©l√®gue √†
              filter.
						</aside>
          </section>
          <section>
            mais cela emp√™che les "refutable patterns" de fonctionner :
            <pre><code class="scala" data-trim>
              for (x: Int <- Good(1)) yield x
              // error: type mismatch;
              // found   : Boolean(true)
              // required: org.scalactic.Validation[?]
            </code></pre>
						<aside class="notes">
              Ou alors je n'ai pas trouv√© comment faire.
						</aside>
          </section>

          <!-- 5.5. Divers Scalactic -->
          <section>
            <h3>Every VS cats.NonEmptyList</h3>
            <ul>
              <li class="fragment">
                conversion implicite vers IndexedSeq<br/>
                => meilleure int√©gration avec la STL (et oui !)
              </li>
              <li class="fragment">scalactic.NonEmptyList (anciennement Chain)</li>
            </ul>
						<aside class="notes">
              Tr√®s subjectif.

              Meilleure int√©gration √† l'usage avec la librairie standard tandis 
              que cats.NEL est plus pens√©e pour s'int√©grer avec les autres collections 
              de cats.

              Every back√© par un Vector (IndexedSeq), NonEmptyList par une List 
              comme cats (dispose aussi d'une conversion implicite).
						</aside>
          </section>
          <section>
            <h3>Diverses AnyVals</h3>
            <ul>
              <li>PosInt</li>
              <li>NegZDouble</li>
              <li>NonEmptyMap</li>
              <li>...</li>
            </ul>
						<aside class="notes">
              Tout un tas d'AnyVals, surtout depuis la 3.1.0 avec lesquelles je 
              n'ai pas encore essay√© de jouer mais je devrais.
						</aside>
          </section>

				</section>
				
        <!-- cats.Validated ? -->
        
        <!-- 6. Composition -->
        <section>
          <section>
            <h2>Composition de monades</h2>
          </section>
          <section>
            <h3>API</h3>
            <pre><code class="scala" data-trim>
              trait FileDownloadService {
                def toHdfs(from: Url, auth: Auth): HdfsPath Or DownloadError
                def toS3(from: Url, auth: Auth): Either[DownloadError, S3Path]
              }
              
              sealed trait DownloadError
              case class GetFailed(code: StatusCode) extends DownloadError
              case object GotHtml extends DownloadError
            </code></pre>
						<aside class="notes">
              Que vous utilisiez Either ou Or, vous aimez bien typer vos erreurs 
              m√©tiers.
              Ces erreurs peuvent servir √† renvoyer des messages pr√©cis √† 
              l'utilisateur ou √† r√©agir en fonction.
              On ne t√©l√©charge pas des HTML. Si on en obtient, c'est qu'on s'est 
              tromp√© d'Url.
						</aside>
          </section>
          <section>
            <h3>Asynchronisme</h3>
            <pre><code class="scala" data-trim>
              trait FileDownloadService {
                def toHdfs(from: Url, auth: Auth): Future[HdfsPath Or DownloadError]
                def toS3(from: Url, auth: Auth): Future[Either[DownloadError, S3Path]]
              }
            </code></pre>
						<aside class="notes">
              Vu qu'on va faire une requ√™te HTTP et √©crire sur un syst√®me de fichier
              distant, il para√Æt l√©gitime de vouloir en faire un traitement asynchrone
						</aside>
          </section>
          <section>
            <h3>Probl√®mes</h3>
            <ul>
              <li class="fragment">
                acc√®s compliqu√© au r√©sultat
                <pre><code class="scala" data-trim>
                  download.toS3(someUrl, someAuth)
                    .map(_.foreach { s3Path => /*...*/ } )
                </code></pre>
              </li>
              <li class="fragment">
                double canal d'erreur
                <pre><code class="scala" data-trim>
                  download.toS3(someUrl, someAuth) 
                  // Future(Failure(java.lang.Exception))
                  // Future(Success(Bad(GotHtml)))
                </code></pre>
              </li>
            </ul>
						<aside class="notes">
              Tuyauterie permanente au lieu d'√™tre limit√©e aux fronti√®res de 
              l'utilisation de certains types.

              Les canaux d'erreurs sont trois en r√©alit√© avec le lancement 
              d'exceptions en dehors de la Future.
						</aside>
          </section>
        </section>



				<!-- 7. Alternatives pour la composition / l'asynchronisme -->
				<section>
					<section data-transition=none>
						<h2>Composition / Asynchronisme</h2>
						<ul>
							<li>Monad transformer maison</li>
							<li>cats.EitherT (monad transformer)</li>
							<li>cats.IO</li> <!-- √† v√©rifier -->
							<li>ZIO</li>
							<li>...</li>
							<!-- list more ? -->
						</ul>
						<aside class="notes">
              Il existe aussi un paquet d'alternatives pour faire de la composition 
              ou de l'asynchronisme avec des erreurs typ√©ees, entre autres ...
						</aside>
					</section>
					<section data-transition=none>
						<h2>Composition / Asynchronisme</h2>
						<ul>
							<li><mark>Monad transformer maison</mark></li>
							<li>cats.EitherT (monad transformer)</li>
							<li>cats.IO</li> <!-- √† v√©rifier -->
							<li><mark>ZIO</mark></li>
							<li>...</li>
							<!-- list more ? -->
						</ul>
						<aside class="notes">
							L√† aussi, on va se concentrer sur celles que j'ai essay√©.
						</aside>
					</section>
        </section>
        


        <!-- 8. Monad transformer maison -->
        <section>
          <h2>FutureOr</h2>
          <ul>
            <li class="fragment">marrant 5 minutes</li>
            <li class="fragment">filterEventually ? eventualFilter ? filter ?</li>
            <li class="fragment">peu performant ?</li>
            <li class="fragment">pas du code que vous voulez maintenir</li>
          </ul>
          <aside class="notes">
            Facile pour map ete flatMap, le reste c'est moins dr√¥le quand vous 
            devez livrer.

            Risque d'incompr√©hension des coll√®gues.
          </aside>
        </section>

        <!-- 9. ZIO -->
        <section>
          <section>
            <h2>ZIO</h2>
            <ul class="fragment">
              <li>originaire de ScalaZ</li>
              <li>programmation concurrente fonctionnelle et type-safe</li>
              <li>IO monad</li>
            </ul>
            <aside class="notes">
              On ne la pr√©sente plus.
              Effect type / IO monad d'Haskell (pas vraiment important de 
              comprendre tout √ßa pour l'utiliser en vrai).
            </aside>
          </section>
          <section>
            <h3>ZIO</h3>
            <div class="fragment">
              <pre><code class="scala" data-trim>
                trait ZIO[R, E, A]
              </code></pre>
              <ul>
                <li>R - environement</li>
                <li>E - √©chec</li>
                <li>A - succ√®s</li>
              </ul>
            </div>
            <aside class="notes">
              R je ne ma√Ætrise pas, injection de d√©pendances.
            </aside>
          </section>
          <section>
            <h3>IO</h3>
            <pre><code class="scala" data-trim>
              type IO[E, A] = ZIO[Any, E, A]
            </code></pre>
            <ul>
              <li>E - √©chec</li>
              <li>A - succ√®s</li>
            </ul>
            <aside class="notes">
              C'est exactement ce qu'on veut.
              Erreur √† gauche.
            </aside>
          </section>
          <section>
            <h3>Utilisation 1/3</h3>
            <pre><code class="scala" data-trim>
              val io = IO.succeed(21).map(_ * 2)

              // thread pools
              val runtime = new zio.DefaultRuntime {}

              // en principe 1 seul appel unique dans le main
              runtime.unsafeRun(io) // 42
            </code></pre>
          </section>
          <section>
            <h3>Utilisation 2/3</h3>
            <pre><code class="scala" data-trim>
              val io = IO.fail("No no!").mapError(_.toUppercase)

              runtime.unsafeRun(io) // ~ throw new Exception("NO NO!")
            </code></pre>
          </section>
          <section>
            <h3>Utilisation 3/3</h3>
            <pre><code class="scala" data-trim>
              val io = for {
                i <- IO.succeed(21)
                _ <- IO.fail("No no!")
              } yield i

              val io2 = io.map(_ * 2).mapError(_.toUppercase)

              runtime.unsafeRun(io2) // throw new Exception("NO NO!")
            </code></pre>
          </section>
          <section>
            <h3>Tuyauterie</h3>
            <pre><code class="scala" data-trim>
              val io = IO.fromFuture(implicit ec => Future(1))
              // IO.fromEither(...)
              // IO.fromTry(...)
              // IO.fromOption(...)
              // IO.fromFunction(...)

              runtime.unsafeRunToFuture(io) // Future(Success(1))
              runtime.unsafeRunSync(io).toEither // Right(1)
            </code></pre>
          </section>
          <section>
            <h3>ZIO API</h3>
            <pre><code class="scala" data-trim>
              trait FileDownloadService {
                def toHdfs(from: Url, auth: Auth): IO[DownloadError, HdfsPath]
                def toS3(from: Url, auth: Auth): IO[DownloadError, S3Path]
              }
            </code></pre>
          </section>
          <section>
            <h3>Pourquoi ne pas mettre du ZIO partout ?</h3>
            <ul>
              <li class="fragment">force l'utilisateur √† faire du ZIO...</li>
              <li class="fragment">
                ...ou √† avoir un zio.Runtime sous la main (co√ªteux)
              </li>
              <li class="fragment">
                le type IO ne veut rien dire
                <pre><code class="scala" data-trim>
                  def retire(worker: Worker): IO[CannotRetireError, Pensioner]
                </code></pre>
              </li>
            </ul>
            <aside class="notes">
              Demander √† l'audience ?
              C'est une des erreurs principales.
              Peut-√™tre que des IO monads plus g√©n√©riques comme (cats.IO ?) permettent 
              de contourner le probl√®me de co√ªt.
              Le type IO n'a du sens que dans le main, ce qui est rarement le cas dans 
              nos bases de code qui font du akka-stream, du Play ou du Slick, etc. 
              o√π on introduit ZIO.
              Probablement beaucoup plus troublant pour des gens non habitu√©s √† 
              typer leurs erreurs que du Or ou du Either.
              Donc √† ne pas en abuser quitte √† faire de la tuyauterie encore une fois.
            </aside>
          </section>
          <section>
            <h2>ZIO == BetterFuture (only)</h2>
            <aside class="notes">
              Mon cas d'usage √† l'heure actuelle. Pour le canal d'erreurs.
            </aside>
          </section>
          <section>
            <h3>Divers ZIO</h3>
            <ul>
              <li class="fragment">withFilter OK</li>
              <li class="fragment">accumulation KO</li>
              <li class="fragment">traverse OK</li>
            </ul>
            <aside class="notes">
              Beaucoup de choses √† dire sur ZIO mais ce n'est pas le sujet de 
              cette pr√©sentation.
            </aside>
          </section>
        </section>



        <section>
          <h1>There is no silver bullet.</h1>
          <aside class="notes">
            Comme d'hab.
          </aside>
        </section>
        <section>
          <h2>Utilisez les types pour faire passer vos intentions !</h2>
          <pre><code class="scala" data-trim>
            def validateFile(file: File): Or[DataFile, UnexpectedFile]

            def classifyFile(file: File): Either[SourceFile, BinaryFile]

            def download(from: Url, auth: Auth): IO[DownloadError, Path]
          </code></pre>
        </section>
        <section>
          <h1>Merci !</h1>
        </section>



			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>

	</body>

</html>
