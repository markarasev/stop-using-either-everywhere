<!doctype html>
<html>

	<head>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>

	<body>

		<div class="reveal">
			<div class="slides">

				<!-- Titre -->
				<section>
					<h1>Stop using <mark>Either</mark> everywhere!</h1>
					<aside class="notes">
						Type dont je trouve l'usage abusif dans beaucoup de bases de code. Je 
						vais tenter d'expliquer pourquoi je pense comme √ßa, et quelles 
						alternatives j'ai pu trouver.
						Sujet √† d√©bat, je vais donner beaucoup d'avis personnels. Si vous n'√™tes
						pas d'accord, c'est normal. Cela dit, tout se dont je vais parler ici 
						est inspir√© de faits r√©els, issus de mon exp√©rience de d√©veloppeur.
					</aside>
				</section>

				<!-- 1. Exemples d'utilisation -->
				<section>
					<section>
						<h2>Quelques exemples d'utilisation</h2>
						√Ä vous de me donner l'intention de l'auteur.
						<aside class="notes">
							chaque mauvaise r√©ponse = une pr√©sentation au SLUG
							(ya pas de mauvaises r√©ponses)
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[FileValidationError, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">FileValidationError est une erreur m√©tier</li>
							<li class="fragment">DataFile est l'entr√©e valid√©e</li>
						</ul>
						<aside class="notes">
							convention : erreurs √† gauche (merci pour les gauchers), r√©sultats 
							corrects √† droite
						</aside>
					</section>
					<!-- Pas s√ªr que ce soit franchement n√©cessaire √† ce stade. C'est bien 
					pour l'exhaustivit√© mais risque de perdre de vue l'objectif de montrer 
					l'ambigu√Øt√©. -->
					<!-- <section>
						<pre><code class="scala" data-trim>
							def decodeFile(file: File): Either[FileDecodingError, DecodedFile]
						</code></pre>
						<ul> -->
							<!-- augmenter l'espacement entre les lignes ? -->
							<!-- <li class="fragment">traitement</li>
							<li class="fragment">FileDecodingError est une erreur de traitement</li>
							<li class="fragment">DecodedFile est le r√©sultat du traitement</li>
						</ul>
						<aside class="notes">
						</aside>
					</section> -->
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[SourceFile, BinaryFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">cat√©gorisation</li>
							<li class="fragment">BinaryFile est une entr√©e m√©tier √† traiter</li>
							<li class="fragment">SourceFile aussi</li>
						</ul>
						<aside class="notes">
							DAFUK le biais √† droite ?
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">DataFile est l'entr√©e valid√©e</li>
							<li class="fragment">
								UnexpectedFile est une erreur m√©tier (plus ambigu qu'
								UnexpectedFileError ou FileValidationError)
							</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">DataFile est une entr√©e m√©tier √† traiter</li>
							<li class="fragment">
								UnexpectedFile ressemble √† une erreur mais en est-ce une vraiment ?
							</li>
							<li class="fragment">cat√©gorisation ou validation ?</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">cat√©gorisation ?</li>
							<li class="fragment">
								UnexpectedFile ressemble √† une erreur mais est √† droite
							</li>
							<li class="fragment">
								DataFile ressemble √† une entr√©e m√©tier √† traiter mais est √† gauche
							</li>
							<li class="fragment">brainfuck</li>
						</ul>
						<aside class="notes">
							√áa, c'est du code que j'ai √©crit. Si un jour tu tombes dessus Sylvain, 
							tu seras pr√©venu.
						</aside>
					</section>
					<!-- refaire les m√™mes exemples avec Or plus tard et voir comment 
						l'interpr√©tation √©volue (moins de doutes, d√©tetion d'erreurs de 
						programmation ?).-->
				</section>

				<!-- 
					ici ou plus bas : oui mais Marc, pourquoi tu fais pas une sealed family? 
					Ben peut-√™tre que j'ai pas la main sur les d√©finitions des types DataFile, 
					UnexpectedFile, SourceFile et BinayFile et qu'elles se trouvent dans des 
					d√©pendances externes. Les wrapper dans une sealed family reviendrait √† 
					faire exactement la m√™me chose qu'Either. Et m√™me, √ßa serait 
					potentiellement r√©barbatif si je devais faire une sealed family par 
					couple que je souhaite retourner √† chaque fonction.
				-->

				<!-- 2. C'est quoi Either ? -->
				<section>
					<section>
						<h2>Mais au fait, c'est quoi <mark>Either</mark> exactement ?</h2>
					</section>
					<!-- This is cool but I don't want to rely on internet connection. -->
					<!-- <section data-background-iframe="https://www.scala-lang.org/api/current/scala/util/Either.html"> -->
					<!-- </section> -->
					<section>
						<img data-src="assets/either_scaladoc.png">
					</section>
					<section>
						<h3>Qu'est-ce qu'une r√©union disjointe ? üá´üá∑üêî</h3>
						<ul>
							<li class="fragment">coproduit</li>
							<li class="fragment">sum type</li>
							<li class="fragment">(encore plein d'autres noms)</li>
							<!-- Utiliser autre chose qu'Either/Left/Right ici ? 
								Fruit/Apple/Banana ? Autre chose de plus binaire ? -->
							<li class="fragment"><pre><code class="scala" data-trim>
								sealed trait Either
								case object Left extends Either
								case object Right extends Either
							</code></pre></li>
						</ul>
						<aside class="notes">
							Pourquoi ya autant de noms pour d√©signer la m√™me chose ? Je ne sais 
							pas, demandez aux scientifiques.
						</aside>
					</section>
					<section>
						S√©mantiquement...
						<pre class="fragment"><code class="scala" data-trim>
							sealed trait File
							case object BinaryFile extends File
							case object SourceFile extends File
							val file: File = ???
						</code></pre>
						<div class="fragment">
							<h3><==></h3>
							<pre><code class="scala" data-trim>
								case object BinaryFile
								case object SourceFile
								val file: Either[BinaryFile, SourceFile] = ???
							</code></pre>
						</div>
					</section>
				
					<!-- relister les diff√©rents exemples sur une slide -->
					<!-- placer ici ou ailleurs que devant les multiples cas d'usages 
						d'Either, s'appuyer uniquement sur une convention est insuffisant, 
						le type est trop g√©n√©ral -->
					<!-- d√©placer ces notes dans une sous-slide ailleurs -->
					<aside class="notes">
						L'interpr√©tation d√©pend du contexte, de l'exp√©rience de celui qui 
						lit le code et de son parcours, des coding-rules de l'√©quipe, etc.
					</aside>
					<!-- autres inconv√©nients d'Either ici ? (implicit class 
					maison pour scala 2.11, withFilter 2.12?, ) -->
				</section>

				<!-- validation, il existe un paquet de libs (en lister) pour en faire 
					mais on ne parlera que de celles que je connais, introduire scalactic 
					et Or, cats.Validated ? -->
				<!-- reprendre les exemples et proposer des alternatives si n√©cessaire -->
				<!-- avantages / inconv√©nients (tuyauterie [mais c'est la garantie de ne 
					pas faire n'importe quoi ?], badMap, map, meaningful type over convention, 
					Every > cats.Nel, accumulation, limitations: see TRM code [??], aurait 
					pu respecter la convention, ...) -->
				
				<!-- partie 2 : composition avec d'autres monades -->
				<!-- probl√®me de l'API asynchrone avec gestion des erreurs (proposer une 
					API exemple) : Future[Either], Future[Or], m√™me combat -->
				<!-- Monad transformer ? Naah. -->
				<!-- liste de solutions (cats.IO, EitherT, ZIO), on ne parlera que de 
					celles que je connais encore une fois -->
				<!-- ZIO, avantages / inconv√©nients (requiert un zio.Runtime [threadpools], 
					ou force l'utilisateur √† faire du ZIO,
					donc √† ne pas en abuser quitte √† faire de la tuyauterie en core une fois, 
					peut-√™tre que des IO monads plus g√©n√©riques [comme cats.IO ?] permettent 
					de contourner ce probl√®me, cependant IO ne veut toujours rien dire [sauf 
					si tout le main est dans une IO monad, ce qui est rarement le cas dans 
					nos bases de code qui font du akka-stream, etc o√π on introduit ZIO]) 
					en r√©sum√© = better Future (canal d'erreurs)
				-->
				<!-- how about IO[Every[Err], Res]? -->
				<!-- revoir l'API avec ZIO, porbl√®me de la compatibilit√© erreurs / 
					exceptions ? -->
				<!-- Option ? autres ? -->

				<!-- liste d'exemples Either / Or / IO et demander √† l'audience ce qu'elle 
					en pense ? -->

				<!-- comme d'hab, there is no silver bullet -->
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>

	</body>

</html>
