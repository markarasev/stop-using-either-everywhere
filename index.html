<!doctype html>
<html>

	<head>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Stop Using Either Everywhere!</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>

	<body>

		<div class="reveal">
			<div class="slides">



				<!-- Titre -->
				<section>
					<h1>Stop using <mark>Either</mark> everywhere!</h1>
					<aside class="notes">
						Type dont je trouve l'usage abusif dans beaucoup de bases de code. Je 
						vais tenter d'expliquer pourquoi je pense comme √ßa, et quelles 
						alternatives j'ai pu trouver.
						Sujet √† d√©bat, je vais donner beaucoup d'avis personnels. Si vous n'√™tes
						pas d'accord, c'est normal. Cela dit, tout se dont je vais parler ici 
						est inspir√© de faits r√©els, issus de mon exp√©rience de d√©veloppeur.
					</aside>
				</section>



				<!-- 1. Exemples d'utilisation -->
				<section>
					<section>
						<h2>Quelques exemples d'utilisation</h2>
						√Ä vous de me donner l'intention de l'auteur.
						<aside class="notes">
							chaque mauvaise r√©ponse = une pr√©sentation au SLUG
							(ya pas de mauvaises r√©ponses)
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[FileValidationError, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">FileValidationError est une erreur m√©tier</li>
							<li class="fragment">DataFile est l'entr√©e valid√©e</li>
						</ul>
						<aside class="notes">
							convention : erreurs √† gauche (merci pour les gauchers), r√©sultats 
							corrects √† droite
						</aside>
					</section>
					<!-- Pas s√ªr que ce soit franchement n√©cessaire √† ce stade. C'est bien 
					pour l'exhaustivit√© mais risque de perdre de vue l'objectif de montrer 
					l'ambigu√Øt√©. -->
					<!-- <section>
						<pre><code class="scala" data-trim>
							def decodeFile(file: File): Either[FileDecodingError, DecodedFile]
						</code></pre>
						<ul> -->
							<!-- augmenter l'espacement entre les lignes ? -->
							<!-- <li class="fragment">traitement</li>
							<li class="fragment">FileDecodingError est une erreur de traitement</li>
							<li class="fragment">DecodedFile est le r√©sultat du traitement</li>
						</ul>
						<aside class="notes">
						</aside>
					</section> -->
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[SourceFile, BinaryFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">cat√©gorisation</li>
							<li class="fragment">BinaryFile est une entr√©e m√©tier √† traiter</li>
							<li class="fragment">SourceFile aussi</li>
						</ul>
						<aside class="notes">
							DAFUK le biais √† droite ?
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">DataFile est l'entr√©e valid√©e</li>
							<li class="fragment">
								UnexpectedFile est une erreur m√©tier (plus ambigu qu'
								UnexpectedFileError ou FileValidationError)
							</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">DataFile est une entr√©e m√©tier √† traiter</li>
							<li class="fragment">
								UnexpectedFile ressemble √† une erreur mais en est-ce une vraiment ?
							</li>
							<li class="fragment">cat√©gorisation ou validation ?</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">cat√©gorisation ?</li>
							<li class="fragment">
								UnexpectedFile ressemble √† une erreur mais est √† droite
							</li>
							<li class="fragment">
								DataFile ressemble √† une entr√©e m√©tier √† traiter mais est √† gauche
							</li>
							<li class="fragment">brainfuck</li>
						</ul>
						<aside class="notes">
							√áa, c'est du code que j'ai √©crit. Si un jour tu tombes dessus Sylvain, 
							tu seras pr√©venu.
						</aside>
					</section>
					<!-- refaire les m√™mes exemples avec Or plus tard et voir comment 
						l'interpr√©tation √©volue (moins de doutes, d√©tetion d'erreurs de 
						programmation ?).-->
				</section>



				<!-- 2. C'est quoi Either ? -->
				<section>
					<section>
						<!-- trouver un meilleur truc pour mettre en valeur le code dans les 
							titres -->
						<h2>Mais au fait, c'est quoi <mark>Either</mark> exactement ?</h2>
					</section>
					<!-- This is cool but I don't want to rely on internet connection. -->
					<!-- <section data-background-iframe="https://www.scala-lang.org/api/current/scala/util/Either.html"> -->
					<!-- </section> -->
					<section>
						<img data-src="assets/either_scaladoc.png">
					</section>
					<section>
						<h3>Qu'est-ce qu'une r√©union disjointe ? üá´üá∑üêî</h3>
						<ul>
							<li class="fragment">coproduit</li>
							<li class="fragment">sum type</li>
							<li class="fragment">(encore plein d'autres noms)</li>
							<!-- Utiliser autre chose qu'Either/Left/Right ici ? 
								Fruit/Apple/Banana ? Autre chose de plus binaire ? -->
							<li class="fragment"><pre><code class="scala" data-trim>
								sealed trait Either
								case object Left extends Either
								case object Right extends Either
							</code></pre></li>
						</ul>
						<aside class="notes">
							Pourquoi ya autant de noms pour d√©signer la m√™me chose ? Je ne sais 
							pas, demandez aux scientifiques.
						</aside>
					</section>
					<section>
						S√©mantiquement...
						<pre class="fragment"><code class="scala" data-trim>
							sealed trait File
							case object BinaryFile extends File
							case object SourceFile extends File
							val file: File = ???
						</code></pre>
						<div class="fragment">
							<h3><==></h3>
							<pre><code class="scala" data-trim>
								case object BinaryFile
								case object SourceFile
								val file: Either[BinaryFile, SourceFile] = ???
							</code></pre>
						</div>
					</section>
					<!-- Ici ou entre les parties 1 et 2 ? L'avantage d'ici c'est les sealed 
					families ont d√©j√† √©t√© √©voqu√©es. -->
					<section>
						<h3>Pourquoi utiliser Either[BinaryFile, SourceFile] ?</h3>
						<ul>
							<li class="fragment">pas forc√©ment le besoin (ni le temps) de tout mod√©liser tout le temps</li>
							<li class="fragment"><pre><code class="scala" data-trim>
								import fancy.jar.BinaryFile
								import other.fancy.jar.SourceFile
	
								val file: Either[BinaryFile, SourceFile] = ???
							</code></pre></li>
						</ul>
						<aside class="notes">
							Oui mais Marc, pourquoi tu fais pas une sealed family 
							(et on garderait Either pour la gestion d'erreurs) ? 

							 - Pour le retour d'une seule fonction, c'est peut-√™tre overkill.

							 - Peut-√™tre que j'ai pas la main sur les d√©finitions des types 
							SourceFile et BinaryFile et qu'elles se trouvent dans des 
							d√©pendances externes. Les wrapper dans une sealed family reviendrait √† 
							faire exactement la m√™me chose qu'Either. Et m√™me, √ßa serait 
							potentiellement tr√®s r√©barbatif si je devais faire une sealed family 
							par couple que je souhaite retourner √† chaque fonction.
						</aside>
					</section>
				</section>



				<!-- 3. Pourquoi Either c'est pas toujours bien ? -->
				<section>
					<section>
						<h2>Pourquoi utiliser <mark>Either</mark> n'est pas toujours id√©al ?</h2>
					</section>
					<section>
						<!-- Trouver mieux comme titre ? -->
						<h3>Le code est la montagne √† gravir</h3>
						<p>L'interpr√©tation du code d√©pend :</p>
						<ul>
							<li class="fragment">du contexte du projet</li>
							<li class="fragment">de l'exp√©rience personnelle du lecteur</li>
							<li class="fragment">des coding-rules de l'√©quipe (conventions)</li>
							<li class="fragment">etc.</li>
						</ul>
						<p class="fragment">Beaucoup de variables.</p>
					</section>
					<section>
						<h3>Les types sont des amis</h3>
						<p>L'interpr√©tation d'un type d√©pend (id√©alement) :</p>
						<ul>
							<li class="fragment">de sa d√©finition uniquement</li>
						</ul>
						<!-- TODO espacer -->
						<p class="fragment">Or la combinaison de la d√©finition d'Either et 
							son usage conventionnel cr√©ent de l'ambigu√Øt√©.</p>
						<!-- ins√©rer GIF ? peut-√™tre 
							https://giphy.com/gifs/filmeditor-christmas-movies-vanessa-ferlito-3o6wrFfkrw1xEk35VS ? -->
						<aside class="notes">
							Les types sont aussi l√† pour nous aider dans cette t√¢che (en principe).
						</aside>
					</section>
					<section>
						<h3>Either est trop g√©n√©ral</h3>
						<!-- def decodeFile(file: File): Either[FileDecodingError, DecodedFile] -->
						<pre><code class="scala" data-trim>
							// validation : Left = erreur
							def validateFile(file: File): Either[FileValidationError, DataFile]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[SourceFile, BinaryFile]

							// validation ?
							def validateFile(file: File): Either[UnexpectedFile, DataFile]

							// cat√©gorisation ?
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]

							// ??
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<aside class="notes">
							<!-- devant les multiples cas d'usages d'Either -->
							Si on reprend nos exemples de d√©part mon avis est que s'appuyer 
							uniquement sur une convention est insuffisant, car le type est trop 
							g√©n√©ral.
						</aside>
					</section>
					<section>
						<h3>Scala 2.11</h3>
						<pre><code class="scala" data-trim>
							object MonadicEither {

							  implicit class EitherMonadicOps[A, B](e: Either[A, B]) {

						      def flatMap[A1 >: A, B1](f: B => Either[A1, B1]): Either[A1, B1] = 
						        e match {
						          case Right(b) => f(b)
						          case _        => e.asInstanceOf[Either[A1, B1]]
						        }
										
						        /* ... */
						</code></pre>
						<pre><code class="scala" data-trim>
							import MonadicEither._

							Right(1).flapMap(Left("Error"))
						</code></pre>
						<aside class="notes">
							Qui utilise encore scala 2.11 ? Nous mais chut.
							On copie-colle du code, mais aimerait faire autre chose de notre 
							temps et √©viter de maintenir ce code, m√™me si il y a peu de risques.
						</aside>
					</section>
					<section>
						<h3>Cross-compile</h3>
						<img data-src="assets/monadic_either.png">
						<pre><code class="scala" data-trim>
							// scala 2.12
							object MonadicEither
						</code></pre>
						<pre><code class="scala" data-trim>
							import MonadicEither._

							Right(1).flapMap(Left("Error"))
						</code></pre>
						<aside class="notes">
							Oblig√©s d'avoir un objet MonadicEither vide en scala 2.12+ pour
							cross-compiler du code en 2.11.
						</aside>
					</section>
					<!-- autres inconv√©nients d'Either ici ? (withFilter 2.12?, ) -->
					<!-- voir test-scala -->
				</section>



				<!-- validation, il existe un paquet de libs (en lister) pour en faire 
					mais on ne parlera que de celles que je connais, introduire scalactic 
					et Or, cats.Validated ? -->
				<!-- reprendre les exemples et proposer des alternatives si n√©cessaire -->
				<!-- avantages / inconv√©nients (tuyauterie [mais c'est la garantie de ne 
					pas faire n'importe quoi ?], badMap, map, meaningful type over convention, 
					Every > cats.Nel, accumulation, limitations: see TRM code [??], aurait 
					pu respecter la convention, ...) -->
				
				<!-- partie 2 : composition avec d'autres monades -->
				<!-- probl√®me de l'API asynchrone avec gestion des erreurs (proposer une 
					API exemple) : Future[Either], Future[Or], m√™me combat -->
				<!-- Monad transformer ? Naah. -->
				<!-- liste de solutions (cats.IO, EitherT, ZIO), on ne parlera que de 
					celles que je connais encore une fois -->
				<!-- ZIO, avantages / inconv√©nients (requiert un zio.Runtime [threadpools], 
					ou force l'utilisateur √† faire du ZIO,
					donc √† ne pas en abuser quitte √† faire de la tuyauterie en core une fois, 
					peut-√™tre que des IO monads plus g√©n√©riques [comme cats.IO ?] permettent 
					de contourner ce probl√®me, cependant IO ne veut toujours rien dire [sauf 
					si tout le main est dans une IO monad, ce qui est rarement le cas dans 
					nos bases de code qui font du akka-stream, etc o√π on introduit ZIO]) 
					en r√©sum√© = better Future (canal d'erreurs)
				-->
				<!-- how about IO[Every[Err], Res]? -->
				<!-- revoir l'API avec ZIO, porbl√®me de la compatibilit√© erreurs / 
					exceptions ? -->
				<!-- Option ? autres ? -->

				<!-- liste d'exemples Either / Or / IO et demander √† l'audience ce qu'elle 
					en pense ? -->

				<!-- comme d'hab, there is no silver bullet -->
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>

	</body>

</html>
