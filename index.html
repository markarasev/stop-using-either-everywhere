<!doctype html>
<html>

	<head>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Stop Using Either Everywhere!</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>

	<body>

		<div class="reveal">
			<div class="slides">



				<!-- Titre -->
				<section>
					<h1>Stop using <mark>Either</mark> everywhere!</h1>
					<aside class="notes">
						Type dont je trouve l'usage abusif dans beaucoup de bases de code. Je 
						vais tenter d'expliquer pourquoi je pense comme √ßa, et quelles 
						alternatives j'ai pu trouver.
						Sujet √† d√©bat, je vais donner beaucoup d'avis personnels. Si vous n'√™tes
						pas d'accord, c'est normal. Cela dit, tout se dont je vais parler ici 
						est inspir√© de faits r√©els, issus de mon exp√©rience de d√©veloppeur.
					</aside>
				</section>



				<!-- 1. Exemples d'utilisation -->
				<section>
					<section>
						<h2>Quelques exemples d'utilisation</h2>
						√Ä vous de me donner l'intention de l'auteur.
						<aside class="notes">
							chaque mauvaise r√©ponse = une pr√©sentation au SLUG
							(ya pas de mauvaises r√©ponses)
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[FileValidationError, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">FileValidationError est une erreur m√©tier</li>
							<li class="fragment">DataFile est l'entr√©e valid√©e</li>
						</ul>
						<aside class="notes">
							convention : erreurs √† gauche (merci pour les gauchers), r√©sultats 
							corrects √† droite
						</aside>
					</section>
					<!-- Pas s√ªr que ce soit franchement n√©cessaire √† ce stade. C'est bien 
					pour l'exhaustivit√© mais risque de perdre de vue l'objectif de montrer 
					l'ambigu√Øt√©. -->
					<!-- <section>
						<pre><code class="scala" data-trim>
							def decodeFile(file: File): Either[FileDecodingError, DecodedFile]
						</code></pre>
						<ul> -->
							<!-- augmenter l'espacement entre les lignes ? -->
							<!-- <li class="fragment">traitement</li>
							<li class="fragment">FileDecodingError est une erreur de traitement</li>
							<li class="fragment">DecodedFile est le r√©sultat du traitement</li>
						</ul>
						<aside class="notes">
						</aside>
					</section> -->
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[SourceFile, BinaryFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">cat√©gorisation</li>
							<li class="fragment">BinaryFile est une entr√©e m√©tier √† traiter</li>
							<li class="fragment">SourceFile aussi</li>
						</ul>
						<aside class="notes">
							DAFUK le biais √† droite ?
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">validation</li>
							<li class="fragment">DataFile est l'entr√©e valid√©e</li>
							<li class="fragment">
								UnexpectedFile est une erreur m√©tier (plus ambigu qu'
								UnexpectedFileError ou FileValidationError)
							</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">DataFile est une entr√©e m√©tier √† traiter</li>
							<li class="fragment">
								UnexpectedFile ressemble √† une erreur mais en est-ce une vraiment ?
							</li>
							<li class="fragment">cat√©gorisation ou validation ?</li>
						</ul>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<ul>
							<!-- augmenter l'espacement entre les lignes ? -->
							<li class="fragment">cat√©gorisation ?</li>
							<li class="fragment">
								UnexpectedFile ressemble √† une erreur mais est √† droite
							</li>
							<li class="fragment">
								DataFile ressemble √† une entr√©e m√©tier √† traiter mais est √† gauche
							</li>
							<li class="fragment">brainfuck</li>
						</ul>
						<aside class="notes">
							√áa, c'est du code que j'ai √©crit. Si un jour tu tombes dessus Sylvain, 
							tu seras pr√©venu.
						</aside>
					</section>
				</section>



				<!-- 2. C'est quoi Either ? -->
				<section>
					<section>
						<!-- trouver un meilleur truc pour mettre en valeur le code dans les 
							titres -->
						<h2>Mais au fait, c'est quoi <mark>Either</mark> exactement ?</h2>
					</section>
					<!-- This is cool but I don't want to rely on internet connection. -->
					<!-- <section data-background-iframe="https://www.scala-lang.org/api/current/scala/util/Either.html"> -->
					<!-- </section> -->
					<section>
						<img data-src="assets/either_scaladoc.png">
					</section>
					<section>
						<h3>Qu'est-ce qu'une r√©union disjointe ? üá´üá∑üêî</h3>
						<ul>
							<li class="fragment">coproduit</li>
							<li class="fragment">sum type</li>
							<li class="fragment">(encore plein d'autres noms)</li>
							<!-- Utiliser autre chose qu'Either/Left/Right ici ? 
								Fruit/Apple/Banana ? Autre chose de plus binaire ? -->
							<li class="fragment"><pre><code class="scala" data-trim>
								sealed trait Either
								case object Left extends Either
								case object Right extends Either
							</code></pre></li>
						</ul>
						<aside class="notes">
							Pourquoi ya autant de noms pour d√©signer la m√™me chose ? Je ne sais 
							pas, demandez aux scientifiques.
						</aside>
					</section>
					<section>
						S√©mantiquement...
						<pre class="fragment"><code class="scala" data-trim>
							sealed trait File
							case object BinaryFile extends File
							case object SourceFile extends File
							val file: File = ???
						</code></pre>
						<div class="fragment">
							<h3><==></h3>
							<pre><code class="scala" data-trim>
								case object BinaryFile
								case object SourceFile
								val file: Either[BinaryFile, SourceFile] = ???
							</code></pre>
						</div>
					</section>
					<!-- Ici ou entre les parties 1 et 2 ? L'avantage d'ici c'est les sealed 
					families ont d√©j√† √©t√© √©voqu√©es. -->
					<section>
						<h3>Pourquoi utiliser Either[BinaryFile, SourceFile] ?</h3>
						<ul>
							<li class="fragment">pas forc√©ment le besoin (ni le temps) de tout mod√©liser tout le temps</li>
							<li class="fragment"><pre><code class="scala" data-trim>
								import fancy.jar.BinaryFile
								import other.fancy.jar.SourceFile
	
								val file: Either[BinaryFile, SourceFile] = ???
							</code></pre></li>
						</ul>
						<aside class="notes">
							Oui mais Marc, pourquoi tu fais pas une sealed family 
							(et on garderait Either pour la gestion d'erreurs) ? 

							 - Pour le retour d'une seule fonction, c'est peut-√™tre overkill.

							 - Peut-√™tre que j'ai pas la main sur les d√©finitions des types 
							SourceFile et BinaryFile et qu'elles se trouvent dans des 
							d√©pendances externes. Les wrapper dans une sealed family reviendrait √† 
							faire exactement la m√™me chose qu'Either. Et m√™me, √ßa serait 
							potentiellement tr√®s r√©barbatif si je devais faire une sealed family 
							par couple que je souhaite retourner √† chaque fonction.
						</aside>
					</section>
				</section>



				<!-- 3. Pourquoi Either c'est pas toujours bien ? -->
				<section>
					<section>
						<h2>Pourquoi utiliser <mark>Either</mark> n'est pas toujours id√©al ?</h2>
					</section>
					<section>
						<!-- Trouver mieux comme titre ? -->
						<h3>Le code est la montagne √† gravir</h3>
						<p>L'interpr√©tation du code d√©pend :</p>
						<ul>
							<li class="fragment">du contexte du projet</li>
							<li class="fragment">de l'exp√©rience personnelle du lecteur</li>
							<li class="fragment">des coding-rules de l'√©quipe (conventions)</li>
							<li class="fragment">etc.</li>
						</ul>
						<p class="fragment">Beaucoup de variables.</p>
					</section>
					<section>
						<h3>Les types sont des amis</h3>
						<p>L'interpr√©tation d'un type d√©pend (id√©alement) :</p>
						<ul>
							<li class="fragment">de sa d√©finition uniquement</li>
						</ul>
						<!-- TODO espacer -->
						<p class="fragment">Or la combinaison de la d√©finition d'Either et 
							son usage conventionnel cr√©ent de l'ambigu√Øt√©.</p>
						<!-- ins√©rer GIF ? peut-√™tre 
							https://giphy.com/gifs/filmeditor-christmas-movies-vanessa-ferlito-3o6wrFfkrw1xEk35VS ? -->
						<aside class="notes">
							Les types sont aussi l√† pour nous aider dans cette t√¢che (en principe).
						</aside>
					</section>
					<section>
						<h3>Either est trop g√©n√©ral</h3>
						<!-- def decodeFile(file: File): Either[FileDecodingError, DecodedFile] -->
						<pre><code class="scala" data-trim>
							// validation : Left = erreur
							def validateFile(file: File): Either[FileValidationError, DataFile]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[SourceFile, BinaryFile]

							// validation ?
							def validateFile(file: File): Either[UnexpectedFile, DataFile]

							// cat√©gorisation ?
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]

							// ??
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<aside class="notes">
							<!-- devant les multiples cas d'usages d'Either -->
							Si on reprend nos exemples de d√©part, aucun n'est vraiment un m√©susage 
							du type Either. Donc mon avis est que s'appuyer uniquement sur une 
							convention est insuffisant, car le type est trop g√©n√©ral.
						</aside>
					</section>
					<section>
						<h3>Scala 2.11</h3>
						<pre><code class="scala" data-trim>
							object MonadicEither {

							  implicit class EitherMonadicOps[A, B](e: Either[A, B]) {

						      def flatMap[A1 >: A, B1](f: B => Either[A1, B1]): Either[A1, B1] = 
						        e match {
						          case Right(b) => f(b)
						          case _        => e.asInstanceOf[Either[A1, B1]]
						        }
										
						        /* ... */
						</code></pre>
						<pre><code class="scala" data-trim>
							import MonadicEither._

							Right(1).flapMap(Left("Error"))
						</code></pre>
						<aside class="notes">
							Qui utilise encore scala 2.11 ? Nous mais chut.
							On copie-colle du code, mais aimerait faire autre chose de notre 
							temps et √©viter de maintenir ce code, m√™me si il y a peu de risques.
						</aside>
					</section>
					<section>
						<h3>Cross-compile</h3>
						<img data-src="assets/monadic_either.png">
						<pre><code class="scala" data-trim>
							// scala 2.12
							object MonadicEither
						</code></pre>
						<pre><code class="scala" data-trim>
							import MonadicEither._

							Right(1).flapMap(Left("Error"))
						</code></pre>
						<aside class="notes">
							Oblig√©s d'avoir un objet MonadicEither vide en scala 2.12+ pour
							cross-compiler du code en 2.11.
						</aside>
					</section>
					<section>
						<h3>Gardes</h3>
						<pre><code class="scala" data-trim>
							for {
							  i <- Right(1)
							  if i > 0
							} yield i
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// error: value withFilter is not a member of Right[Double,Int]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							for (x: Int <- right1) yield x
							// error: value withFilter is not a member of Right[Double,Int]
						</code></pre>
						<aside class="notes">
							Demander √† l'audience ce qu'il se passe pour le premier exemple.
							
							Les "refutable-patterns" ne fonctionnent pas non plus.
						</aside>
					</section>
					<section>
						<h3>Accumulation d'erreurs</h3>
						<pre><code class="scala" data-trim>
							def retire(worker: Worker): Either[List[CannotRetireError], Pensioner] = {
							  var errors = List.empty // erf
							  if (worker.age < 62) 
							    errors = CannotRetireError.TooYoung +: errors // uuh
							  if (worker.workedQuarters < 172) 
							    errors = CannotRetireError.DidNotWorkedEnough +: errors // ooh
							  if (errors.isEmpty) Right(Pensioner(worker)) else Left(errors)
							}

							val marc = Worker(age = 27, workedQuarters = 15)
							retire(marc) // Left(Seq(TooYoung, DidNotWorkedEnough))
						</code></pre>
						<aside class="notes">
							On est tout nu pour faire de l'accumulation, oblig√© de faire du 
							mutable.
							Ah, et √ßa serait bien d'avoir un type de liste non vide pour les 
							erreurs.
						</aside>
					</section>
					<section>
						<h3>Traverse</h3>
						<pre><code class="scala" data-trim>
							val eithers: List[Either[CannotRetireError, Pensioner]] =
							  Left(TooYoung) :: Right(marc) :: Left(DidNotWorkedEnough) :: Nil

							val todo: Either[List[CannotRetireError], List[Pensioner]] = ???
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
						  val eithers: List[Either[List[CannotRetireError], Pensioner]] = 
						    List(
						      Left(TooYoung :: DidNotWorkedEnough),
						      Right(marc),
						      Left(TooYoung :: Nil)
						    )

						  val todo: Either[List[CannotRetireError], List[Pensioner]] = ???
						</code></pre>
						<p class="fragment">Qui a envie d'√©crire ce code ?</p>
						<aside class="notes">
							(on peut voir que Marc s'en est sorti)
							(si des gens r√©pondent oui dire "√áa me rassure, je ne suis pas le 
							seul √† √™tre masochiste.")
						</aside>
					</section>
				</section>



				<!-- 4. Alternatives pour la validation / gestion des erreurs -->
				<section>
					<section data-transition=none>
						<h3>Validation</h3>
						<ul>
							<li>scalactic.Or</li>
							<li>cats.Validated</li>
							<li>...</li>
							<!-- list more -->
						</ul>
						<aside class="notes">
							Il existe un paquet de libs pour faire de la validation, entre autres ...
							On va se concentrer sur celle que je connais, scalactic.
						</aside>
					</section>
					<section data-transition=none>
						<h3>Validation</h3>
						<ul>
							<li><mark>scalactic.Or</mark></li>
							<li>cats.Validated</li>
							<li>...</li>
							<!-- list more -->
						</ul>
					</section>
				</section>

				<!-- 5. Scalactic -->
				<section>
					<section>
						<h2>Scalactic</h2>
						<ul>
							<li class="fragment">fondation de Scalatest</li>
							<li class="fragment">504 classes</li>
							<li class="fragment">1,5 Mo</li>
							<li class="fragment">d√©veloppement actif</li>
						</ul>
						<aside class="notes">
							- (donc d√©j√† dans ton scope de test si tu utilises Scalatest)
							- petite librairie (cats-core 2.1.0 2072 classes 4,7 Mo) mais plus 
							tellement : a doubl√© de volume entre la 3.0.8 et la 3.1.0 
							(315 -> 504 classes, 706 Ko -> 1,5 Mo)
							- 3.1.0 sortie le 29/11 dernier
						</aside>
					</section>
					<section>
						<h3>scalactic.Or</h3>
						<ul>
							<li class="fragment">Either[L, R] devient Or[G, B]</li>
							<li class="fragment">Left devient Good</li>
							<li class="fragment">Right devient Bad</li>
							<li class="fragment">erreurs √† droite</li>
						</ul>
						<aside class="notes">
							ne respecte pas la convention
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							for {
							  x <- Right(1)
							  y <- Left("Error")
							} yield x + y // Left("Error")
						</code></pre>
						<pre><code class="scala" data-trim>
							for {
							  x <- Good(1)
							  y <- Bad("Error")
							} yield x + y // Bad("Error")
						</code></pre>
						<aside class="notes">
							Les types Good et Bad portent une s√©mantique contrairement √† Left et Right.
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							// validation
							def validateFile(file: File): Either[FileValidationError, DataFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// validation
							def validateFile(file: File): Or[DataFile, FileValidationError]
						</code></pre>
					</section>
					<!-- Pas s√ªr que ce soit franchement n√©cessaire √† ce stade. C'est bien 
					pour l'exhaustivit√© mais risque de perdre de vue l'objectif de montrer 
					l'ambigu√Øt√©. -->
					<!-- <section>
						<pre><code class="scala" data-trim>
							def decodeFile(file: File): Either[FileDecodingError, DecodedFile]
						</code></pre>
						<aside class="notes">
						</aside>
					</section> -->
					<section>
						<pre><code class="scala" data-trim>
							// cat√©gorisation
							def classifyFile(file: File): Either[SourceFile, BinaryFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// Bad[SourceFile] ??
							// erreur de programmation manifeste
							def classifyFile(file: File): Or[BinaryFile, SourceFile]
						</code></pre>
						<aside class="notes">
							Ne doit pas changer, ne rentre pas dans le use-case de Or.
						</aside>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							// UnexpectedFile est une erreur ?
							def validateFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// UnexpectedFile est une erreur car Bad
							def validateFile(file: File): Or[DataFile, UnexpectedFile]
						</code></pre>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							// cat√©gorisation
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// validation
							def classifyFile(file: File): Or[DataFile, UnexpectedFile]
						</code></pre>
					</section>
					<section>
						<pre><code class="scala" data-trim>
							// cat√©gorisation
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							// erreur de programmation manifeste
							def classifyFile(file: File): Or[UnexpectedFile, DataFile]
						</code></pre>
						<aside class="notes">
							Mauvais usage du type Or.
						</aside>
					</section>
					<section>
						<h3>Moins d'ambigu√Øt√©</h3>
						<!-- def decodeFile(file: File): Either[FileDecodingError, DecodedFile] -->
						<pre><code class="scala" data-trim>
							// validation : Bad = erreur
							def validateFile(file: File): Or[DataFile, FileValidationError]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[SourceFile, BinaryFile]

							// validation : Bad = erreur
							def validateFile(file: File): Or[DataFile, UnexpectedFile]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[UnexpectedFile, DataFile]

							// cat√©gorisation : Left = entr√©e valide
							def classifyFile(file: File): Either[DataFile, UnexpectedFile]
						</code></pre>
						<aside class="notes">
							moins de doutes + d√©tetion d'erreurs de programmation
						</aside>
					</section>
					<section>
						<h3>Notation infixe</h3>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): Or[DataFile, FileValidationError]
						</code></pre>
						<pre><code class="scala" data-trim>
							def validateFile(file: File): DataFile Or FileValidationError
						</code></pre>
					</section>
					<section>
						<h3>Every</h3>
						<pre><code class="scala" data-trim>
							One("Too young.") // Every[String]
							
							Many("Too young.", "Did not worked enough.") // Every[String]
						</code></pre>
						<aside class="notes">
							NonEmptyList back√©e par un Vector, va nous servir pour l'accumulation.
						</aside>
					</section>
					<!-- d√©finir DidNotWorkedEnough, Worker et Pensioner ? -->
					<section>
						<pre><code class="scala" data-trim>
							import org.scalactic.Accumulation._
						</code></pre>
					</section>
					<section>
						<h3>Accumulation avec withGood 1/3</h3>
						<pre><code class="scala" data-trim>
							sealed trait ParseError
							case object EmptyName extends ParseError
							case object NegativeAge extends ParseError
							case object InvalidAge extends ParseError
						</code></pre>
						<pre><code class="scala" data-trim>
							case class Person(name: String, age: Int)
						</code></pre>
						<aside class="notes">
							Dans l'exemple qui va suivre on va vouloir valider des inputs textuels 
							pour cr√©er une personne dans notre syst√®me.
						</aside>
					</section>
					<section>
						<h3>Accumulation avec withGood 2/3</h3>
						<pre><code class="scala" data-trim>
							def parseName(input: String): String Or One[EmptyName] = {
							  val trimmed = input.trim
							  if (!trimmed.isEmpty) Good(trimmed) else Bad(One(EmptyName))
							}
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							def parseAge(input: String): Int Or One[ParseError] = try {
							  val age = input.trim.toInt
							  if (age >= 0) Good(age) else Bad(One(NegativeAge))
							} catch { case _: NumberFormatException => Bad(One(InvalidAge)) }
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							def parsePerson(inputName: String, inputAge: String)
							: Person Or Every[ParseError] =
							  withGood(parseName(inputName), parseAge(inputAge)) { 
							    (name, age) => Person(name, age) 
							  }
						</code></pre>
						<aside class="notes">
							Scalactic offre plusieurs moyens de faire de l'accumulation d'erreurs. 

							Notation infixe (j'aime bien pour limiter les []).

							Exemple de la doc.
						</aside>
					</section>
					<section>
						<h3>Accumulation avec withGood 3/3</h3>
						<pre><code class="scala" data-trim>
							parsePerson("Bridget Jones", "29")
							// Result: Good(Person(Bridget Jones,29))
							
							parsePerson("Bridget Jones", "")
							// Result: Bad(One(InvalidAge))
							
							parsePerson("Bridget Jones", "-29")
							// Result: Bad(One(NegativeAge))
							
							parsePerson("", "")
							// Result: Bad(Many(InvalidAge, NegativeAge))
						</code></pre>
						<aside class="notes">
						</aside>
					</section>
					<section>
						<h3>Accumulation avec when 1/2</h3>
						<pre><code class="scala" data-trim>
							sealed trait CannotRetireError
							case object TooYoung extends CannotRetireError
							case object DidNotWorkedEnough extends CannotRetireError
						</code></pre>
						<aside class="notes">
							On revient √† notre exemple avec le syst√®me de retraites dont voici 
							les erreurs.
						</aside>
					</section>
					<section>
						<h3>Accumulation avec when 2/2</h3>
						<pre><code class="scala" data-trim>
							def isOldEnough(worker: Worker): Validation[CannotRetireError] =
							  if (worker.age >= 62) Pass else Fail(TooYoung)
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							def hasWorkedEnough(worker: Worker): Validation[CannotRetireError] =
							  if (worker.workedQuarters >= 172) Pass else Fail(DidNotWorkedEnough)
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							def retire(worker: Worker): Or[Pensioner, Every[CannotRetireError]] = 
							  Good(worker).when(isOldEnough, hasWorkedEnough).map(Pensioner.apply)
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							val marc = Worker(age = 27, workedQuarters = 15)
							retire(marc) // Bad(Many(TooYoung, DidNotWorkedEnough))
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
							val somebody = Worker(age = 65, workedQuarters = 181)
							retire(somebody) // Good(Pensioner(...))
						</code></pre>
          </section>
          <section>
						<pre><code class="scala" data-trim>
              val aGoodOne: Int Or String = Good(1)
              aGoodOne.accumulating // Int Or One[String]
						</code></pre>
          </section>
          <section>
						<h3>Traverse</h3>
						<pre><code class="scala" data-trim>
              val ors: List[Pensioner Or CannotRetireError] =
                Bad(TooYoung) :: Good(marc) :: Bad(DidNotWorkedEnough) :: Nil

              val accumulatingOrs: List[Pensioner Or One[CannotRetireError]] = 
                ors.map(_.accumulating)
                
              val pensionersOrErrors: List[Pensioner] Or Every[CannotRetireError] =
                accumulatingOrs.combined // needs import org.scalactic.Accumulation._
						</code></pre>
						<pre class="fragment"><code class="scala" data-trim>
              val ors: List[Pensioner Or Every[CannotRetireError]] = List(
                Bad(Many(TooYoung, DidNotWorkedEnough)),
                Good(marc),
                Bad(One(TooYoung))
              )

              val pensionersOrErrors: List[Pensioner] Or Every[CannotRetireError] = 
                ors.combined // needs import org.scalactic.Accumulation._
						</code></pre>
						<aside class="notes">
              La subtilit√© c'est qu'il faut √™tre sur des ors accumulatifs.
						</aside>
          </section>
          <section>
            withFilter est d√©fini via Validation :
            <pre><code class="scala" data-trim>
              def greaterThan0(i: Int): Validation[String] =
                if (i > 0) Pass else Fail(s"$i is less than or equal to 0")
                
              for {
                i <- Good(-1)
                if greaterThan0(i)
              } yield i // Bad("-1 is less than or equal to 0")
            </code></pre>
						<aside class="notes">
              Pas tr√®s pratique, en r√©alit√© pas vraiment impl√©ment√©, d√©l√®gue √†
              filter.
						</aside>
          </section>
          <section>
            mais cela emp√™che les "refutable patterns" de fonctionner :
            <pre><code class="scala" data-trim>
              for (x: Int <- Good(1)) yield x
              // error: type mismatch;
              // found   : Boolean(true)
              // required: org.scalactic.Validation[?]
            </code></pre>
						<aside class="notes">
              Ou alors je n'ai pas trouv√© comment faire.
						</aside>
          </section>
					<section>
            pas de diff√©rences entre les versions de Scala
					</section>
					<section>
            <h3>Inconv√©nients de Or 1/x</h3>
              la tuyauterie...
              <pre><code class="scala" data-trim>
                Or.from(Right(1)) // Good(1)
                Or.from(Left("error")) // Bad("error")

                Good(1).toEither // Right(1)
                Bad("error").toEither // Left("error")
              </code></pre>
						<aside class="notes">
              Mais quelque-part, devoir faire de la tuyauterie c'est la garantie 
              de ne pas m√©langer les choux et les carottes, i.e. de ne pas m√©langer 
              des Bad avec des Left qui seraient des valeurs m√©tier.
						</aside>
          </section>
          <section>
            En parlant de tuyauterie :
            <pre><code class="scala" data-trim>
              Or.from(aTry) 
              Or.from(option, orElse)
              
              or.toOption
              or.toSeq
              or.toTry
            </code></pre>
          </section>
          <section>
            <h3>Inconv√©nients de Or 2/x</h3>
            Erreurs √† droite -> principle of least surprise bafou√©
            <!-- TODO spacing -->
            (cats.Validated, ZIO et certainement d'autres respectent la convention)
						<aside class="notes">
              Ne respecte pas la convention (principle of least surprise).
              Pose des probl√®mes aux coll√®gues en cours d'appropriation de la 
              librairie dans une base de code en cours de migration.
						</aside>
          </section>
          <section>
            <h3>Limitations 1/x</h3>
            firstGood?
            <pre><code class="scala" data-trim>
              def resolveFile(inputFile: Path): List[Path] Or Every[InputError] = /*...*/
              def resolveGlob(inputGlob: Path): List[Path] Or Every[InputError] = /*...*/

              val pathsOrErrors: List[Path] Or Every[InputError] = 
                firstGood(resolveFilePath(inputPath), resolveGlobPath(inputPath))
            </code></pre>
						<aside class="notes">
              Validation supporte l'op√©rateur && mais pas ||. Ait d√ª impl√©menter 
              une implicit class de Or avec une m√©thode whenOneOf.
						</aside>
          </section>
          <section>
            <h3>Limitations 2/x</h3>
            Validation ||
            <pre><code class="scala" data-trim>
              def hasFrenchHeaders(file: File): Validation[DecodeError] = /*...*/
              def hasEnglishHeaders(file: File): Validation[DecodeError] = /*...*/

              Good(file).when(hasFrenchHeaders && hasEnglishHeaders) // OK
              Good(file).when(hasFrenchHeaders || hasEnglishHeaders) // compile error
            </code></pre>
          </section>
				</section>

				<!-- avantages / inconv√©nients, combine, meaningful type over convention, 
          Every > cats.Nel, limitations: see TRM code [??], ...) -->
				<!-- new Sclactic NonEmptyCols -->
				<!-- tout un tas d'anyvals (PosInt, NegInt, NonEmptyList) surtout depuis 
					la 3.1.0 avec lesquelles je n'ai pas essay√© de jouer mais je devrais -->
				
				<!-- bosser cats.Validated ? -->

				<!-- partie 2 : composition avec d'autres monades -->
				<!-- probl√®me de l'API asynchrone avec gestion des erreurs (proposer une 
					API exemple) : Future[Either], Future[Or], m√™me combat -->
				<!-- Monad transformer ? Naah. -->
				<!-- liste de solutions (cats.IO, EitherT, ZIO), on ne parlera que de 
					celles que je connais encore une fois -->
				<!-- ZIO, avantages / inconv√©nients (requiert un zio.Runtime [threadpools], 
					ou force l'utilisateur √† faire du ZIO,
					donc √† ne pas en abuser quitte √† faire de la tuyauterie en core une fois, 
					peut-√™tre que des IO monads plus g√©n√©riques [comme cats.IO ?] permettent 
					de contourner ce probl√®me, cependant IO ne veut toujours rien dire [sauf 
					si tout le main est dans une IO monad, ce qui est rarement le cas dans 
					nos bases de code qui font du akka-stream, etc o√π on introduit ZIO]) 
					en r√©sum√© = better Future (canal d'erreurs)
				-->
				<!-- how about IO[Every[Err], Res]? -->
				<!-- revoir l'API avec ZIO, porbl√®me de la compatibilit√© erreurs / 
					exceptions ? -->
				<!-- Option ? autres ? -->

				<!-- liste d'exemples Either / Or / IO et demander √† l'audience ce qu'elle 
					en pense ? -->

				<!-- comme d'hab, there is no silver bullet -->
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>

	</body>

</html>
